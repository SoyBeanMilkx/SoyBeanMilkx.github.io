<!DOCTYPE html>


<html theme="dark" showBanner="true" hasBanner="true" > 
<link href="https://cdn.staticfile.org/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet">
<link href="https://cdn.staticfile.org/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet">
<link href="https://cdn.staticfile.org/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet">
<script src="/js/color.global.min.js" ></script>
<script src="/js/load-settings.js" ></script>
<head>
  <meta charset="utf-8">
  
  
  

  
  <title>ElfLoader的实现及原理 | Yuuki</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="preload" href="/css/fonts/Roboto-Regular.ttf" as="font" type="font/ttf" crossorigin="anonymous">
  <link rel="preload" href="/css/fonts/Roboto-Bold.ttf" as="font" type="font/ttf" crossorigin="anonymous">

  <meta name="description" content="ELFLoader的实现0x01 Loador加载流程linker中，加载so有以下流程：  find_module check_elf_header elf_module_alloc layout_segments find_loaded_phdr phdr_table_get_dynamic_section load_dynamic elf_link list_add_tail  流程概括下来">
<meta property="og:type" content="article">
<meta property="og:title" content="ElfLoader的实现及原理">
<meta property="og:url" content="http://example.com/2024/12/26/ELFLoador/index.html">
<meta property="og:site_name" content="Yuuki">
<meta property="og:description" content="ELFLoader的实现0x01 Loador加载流程linker中，加载so有以下流程：  find_module check_elf_header elf_module_alloc layout_segments find_loaded_phdr phdr_table_get_dynamic_section load_dynamic elf_link list_add_tail  流程概括下来">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2024-12-26T05:14:10.000Z">
<meta property="article:modified_time" content="2024-12-26T08:07:51.689Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="linker">
<meta property="article:tag" content="elf">
<meta name="twitter:card" content="summary">
  
  
    <link rel="shortcut icon" href="/site_img/icon.jpg">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  
  
    
<div id="banner" class="">
  <img src="/site_img/backg.png" itemprop="image">
  <div id="banner-dim"></div>
</div>
 
   
  <div id="main-grid" class="  ">
    <div id="nav" class=""  >
      <navbar id="navbar">
  <nav id="title-nav">
    <a href="/">
      <div id="vivia-logo">
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
      </div>
      <div>Yuuki </div>
    </a>
  </nav>
  <nav id="main-nav">
    
      <a class="main-nav-link" href="/">Home</a>
    
      <a class="main-nav-link" href="/archives">Archives</a>
    
      <a class="main-nav-link" href="/about">About</a>
    
  </nav>
  <nav id="sub-nav">
    <a id="theme-btn" class="nav-icon">
      <span class="light-mode-icon"><svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" width="20"><path d="M438.5-829.913v-48q0-17.452 11.963-29.476 11.964-12.024 29.326-12.024 17.363 0 29.537 12.024t12.174 29.476v48q0 17.452-11.963 29.476-11.964 12.024-29.326 12.024-17.363 0-29.537-12.024T438.5-829.913Zm0 747.826v-48q0-17.452 11.963-29.476 11.964-12.024 29.326-12.024 17.363 0 29.537 12.024t12.174 29.476v48q0 17.452-11.963 29.476-11.964 12.024-29.326 12.024-17.363 0-29.537-12.024T438.5-82.087ZM877.913-438.5h-48q-17.452 0-29.476-11.963-12.024-11.964-12.024-29.326 0-17.363 12.024-29.537t29.476-12.174h48q17.452 0 29.476 11.963 12.024 11.964 12.024 29.326 0 17.363-12.024 29.537T877.913-438.5Zm-747.826 0h-48q-17.452 0-29.476-11.963-12.024-11.964-12.024-29.326 0-17.363 12.024-29.537T82.087-521.5h48q17.452 0 29.476 11.963 12.024 11.964 12.024 29.326 0 17.363-12.024 29.537T130.087-438.5Zm660.174-290.87-34.239 32q-12.913 12.674-29.565 12.174-16.653-.5-29.327-13.174-12.674-12.673-12.554-28.826.12-16.152 12.794-28.826l33-35q12.913-12.674 30.454-12.674t30.163 12.847q12.709 12.846 12.328 30.826-.38 17.98-13.054 30.653ZM262.63-203.978l-32 34q-12.913 12.674-30.454 12.674t-30.163-12.847q-12.709-12.846-12.328-30.826.38-17.98 13.054-30.653l33.239-31q12.913-12.674 29.565-12.174 16.653.5 29.327 13.174 12.674 12.673 12.554 28.826-.12 16.152-12.794 28.826Zm466.74 33.239-32-33.239q-12.674-12.913-12.174-29.565.5-16.653 13.174-29.327 12.673-12.674 28.826-13.054 16.152-.38 28.826 12.294l35 33q12.674 12.913 12.674 30.454t-12.847 30.163q-12.846 12.709-30.826 12.328-17.98-.38-30.653-13.054ZM203.978-697.37l-34-33q-12.674-12.913-13.174-29.945-.5-17.033 12.174-29.707t31.326-13.293q18.653-.62 31.326 13.054l32 34.239q11.674 12.913 11.174 29.565-.5 16.653-13.174 29.327-12.673 12.674-28.826 12.554-16.152-.12-28.826-12.794ZM480-240q-100 0-170-70t-70-170q0-100 70-170t170-70q100 0 170 70t70 170q0 100-70 170t-170 70Zm-.247-82q65.703 0 111.475-46.272Q637-414.544 637-480.247t-45.525-111.228Q545.95-637 480.247-637t-111.475 45.525Q323-545.95 323-480.247t45.525 111.975Q414.05-322 479.753-322ZM481-481Z"/></svg></span>
      <span class="dark-mode-icon"><svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" width="20"><path d="M480.239-116.413q-152.63 0-258.228-105.478Q116.413-327.37 116.413-480q0-130.935 77.739-227.435t206.304-125.043q43.022-9.631 63.87 10.869t3.478 62.805q-8.891 22.043-14.315 44.463-5.424 22.42-5.424 46.689 0 91.694 64.326 155.879 64.325 64.186 156.218 64.186 24.369 0 46.978-4.946 22.609-4.945 44.413-14.076 42.826-17.369 62.967 1.142 20.142 18.511 10.511 61.054Q807.174-280 712.63-198.206q-94.543 81.793-232.391 81.793Zm0-95q79.783 0 143.337-40.217 63.554-40.218 95.793-108.283-15.608 4.044-31.097 5.326-15.49 1.283-31.859.805-123.706-4.066-210.777-90.539-87.071-86.473-91.614-212.092-.24-16.369.923-31.978 1.164-15.609 5.446-30.978-67.826 32.478-108.282 96.152Q211.652-559.543 211.652-480q0 111.929 78.329 190.258 78.329 78.329 190.258 78.329ZM466.13-465.891Z"/></svg></span>
    </a>
    
    <div id="nav-menu-btn" class="nav-icon">
      <svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" width="20"><path d="M177.37-252.282q-17.453 0-29.477-11.964-12.024-11.963-12.024-29.326t12.024-29.537q12.024-12.174 29.477-12.174h605.26q17.453 0 29.477 11.964 12.024 11.963 12.024 29.326t-12.024 29.537q-12.024 12.174-29.477 12.174H177.37Zm0-186.218q-17.453 0-29.477-11.963-12.024-11.964-12.024-29.326 0-17.363 12.024-29.537T177.37-521.5h605.26q17.453 0 29.477 11.963 12.024 11.964 12.024 29.326 0 17.363-12.024 29.537T782.63-438.5H177.37Zm0-186.217q-17.453 0-29.477-11.964-12.024-11.963-12.024-29.326t12.024-29.537q12.024-12.174 29.477-12.174h605.26q17.453 0 29.477 11.964 12.024 11.963 12.024 29.326t-12.024 29.537q-12.024 12.174-29.477 12.174H177.37Z"/></svg>
    </div>
  </nav>
</navbar>
<div id="nav-dropdown" class="hidden">
  <div id="dropdown-link-list">
    
      <a class="nav-dropdown-link" href="/">Home</a>
    
      <a class="nav-dropdown-link" href="/archives">Archives</a>
    
      <a class="nav-dropdown-link" href="/about">About</a>
    
     
    </div>
</div>
<script>
  let dropdownBtn = document.getElementById("nav-menu-btn");
  let dropdownEle = document.getElementById("nav-dropdown");
  dropdownBtn.onclick = function() {
    dropdownEle.classList.toggle("hidden");
  }
</script>
    </div>
    <div id="sidebar-wrapper">
      <sidebar id="sidebar">
  
    <div class="widget-wrap">
  <div class="info-card">
    <div class="avatar">
      
        <image src=/site_img/icon.jpg></image>
      
      <div class="img-dim"></div>
    </div>
    <div class="info">
      <div class="username">Yuuki </div>
      <div class="dot"></div>
      <div class="subtitle">不说话 装高手 </div>
      <div class="link-list">
        
          <a class="link-btn" target="_blank" rel="noopener" href="https://x.com/LiYangv?t=kbZV9-LGilEE-2pg_2GBeQ&s=09" title="Twitter"><i class="fa-brands fa-twitter"></i></a>
        
          <a class="link-btn" target="_blank" rel="noopener" href="https://steamcommunity.com/profiles/76561199358468625/" title="Steam"><i class="fa-brands fa-steam"></i></a>
        
          <a class="link-btn" target="_blank" rel="noopener" href="https://github.com/SoyBeanMilkx" title="GitHub"><i class="fa-brands fa-github"></i></a>
         
      </div>  
    </div>
  </div>
</div>

  
  <div class="sticky">
    
      


  <div class="widget-wrap">
    <div class="widget">
      <h3 class="widget-title">Categories</h3>
      <div class="category-box">
            <a class="category-link" href="/categories/Android/">
                Android
                <div class="category-count">1</div>
            </a>
        
            <a class="category-link" href="/categories/Life/">
                Life
                <div class="category-count">1</div>
            </a>
        </div>
    </div>
  </div>


    
      
  <div class="widget-wrap">
    <div class="widget">
      <h3 class="widget-title">Tags</h3>
      <ul class="widget-tag-list" itemprop="keywords"><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/elf/" rel="tag">elf</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/idea/" rel="tag">idea</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/linker/" rel="tag">linker</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/photo/" rel="tag">photo</a></li></ul>
    </div>
  </div>


    
      
  <div class="widget-wrap">
    <div class="widget">
      <h3 class="widget-title">Archives</h3>
      
      
        <a class="archive-link" href="/archives/2024/12 ">
          December 2024 
          <div class="archive-count">2 </div>
        </a>
      
    </div>
  </div>


    
      
  <div class="widget-wrap">
    <div class="widget">
      <h3 class="widget-title">Recent Posts</h3>
      <ul>
        
          <a class="recent-link" href="/2024/12/26/ELFLoador/" title="ElfLoader的实现及原理" >
            <div class="recent-link-text">
              ElfLoader的实现及原理
            </div>
          </a>
        
          <a class="recent-link" href="/2024/12/25/HelloBlog/" title="NEW BLOG!!" >
            <div class="recent-link-text">
              NEW BLOG!!
            </div>
          </a>
        
      </ul>
    </div>
  </div>

    
  </div>
</sidebar>
    </div>
    <div id="content-body">
       


<article id="post-ELFLoador" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
    
   
  <div class="article-inner">
    <div class="article-main">
      <header class="article-header">
        
<div class="main-title-bar">
  <div class="main-title-dot"></div>
  
    
      <h1 class="p-name article-title" itemprop="headline name">
        ElfLoader的实现及原理
      </h1>
    
  
</div>

        <div class='meta-info-bar'>
          <div class="meta-info">
  <time class="dt-published" datetime="2024-12-26T05:14:10.000Z" itemprop="datePublished">2024-12-26</time>
</div>
          <div class="need-seperator meta-info">
            <div class="meta-cate-flex">
  
  <a class="meta-cate-link" href="/categories/Android/">Android</a>
   
</div>
  
          </div>
          <div class="wordcount need-seperator meta-info">
            19k words 
          </div>
        </div>
        
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/elf/" rel="tag">elf</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linker/" rel="tag">linker</a></li></ul>

      </header>
      <div class="e-content article-entry" itemprop="articleBody">
        
          <h1 id="ELFLoader的实现"><a href="#ELFLoader的实现" class="headerlink" title="ELFLoader的实现"></a>ELFLoader的实现</h1><h2 id="0x01-Loador加载流程"><a href="#0x01-Loador加载流程" class="headerlink" title="0x01 Loador加载流程"></a>0x01 Loador加载流程</h2><p>linker中，加载so有以下流程：</p>
<ol>
<li>find_module</li>
<li>check_elf_header</li>
<li>elf_module_alloc</li>
<li>layout_segments</li>
<li>find_loaded_phdr</li>
<li>phdr_table_get_dynamic_section</li>
<li>load_dynamic</li>
<li>elf_link</li>
<li>list_add_tail</li>
</ol>
<p>流程概括下来就是以上九件事，分别举例说说他们每个都是什么意思吧。</p>
<h2 id="0x02-模块实现"><a href="#0x02-模块实现" class="headerlink" title="0x02 模块实现"></a>0x02 模块实现</h2><h4 id="一、find-module"><a href="#一、find-module" class="headerlink" title="一、find_module"></a>一、find_module</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在链表中查找模块</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> elf_module *<span class="title function_">find_module</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">pos</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">elf_module</span> *<span class="title">m</span> =</span> <span class="literal">NULL</span>, *tmp;</span><br><span class="line"></span><br><span class="line">    list_for_each(pos, &amp;mod_list) &#123;</span><br><span class="line">        tmp = list_entry(pos, <span class="keyword">struct</span> elf_module, <span class="built_in">list</span>);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, tmp-&gt;name)) &#123;</span><br><span class="line">            m = tmp;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (m-&gt;flags &amp; FLAG_LINKED)</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        LOG_ERR(<span class="string">&quot;OOPS: recursive link to \&quot;%s\&quot;&quot;</span>, m-&gt;name);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LOG_DEBUG(<span class="string">&quot;[ \&quot;%s\&quot; has not been loaded yet ]&quot;</span>, name);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h4 id="二、check-elf-header"><a href="#二、check-elf-header" class="headerlink" title="二、check_elf_header"></a>二、check_elf_header</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 校验elf头</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">verify_elf_header</span><span class="params">(<span class="keyword">struct</span> elf_info *info)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> elf_class;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (info-&gt;len &lt; <span class="keyword">sizeof</span>(*(info-&gt;hdr))) &#123;</span><br><span class="line">        LOG_ERR(<span class="string">&quot;\&quot;%s\&quot; is too small to be an ELF executable. Expected at least %zu bytes, &quot;</span></span><br><span class="line">                <span class="string">&quot;only found %zu bytes&quot;</span>, info-&gt;name, <span class="keyword">sizeof</span>(*(info-&gt;hdr)), info-&gt;len);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">memcmp</span>(info-&gt;hdr-&gt;e_ident, ELFMAG, SELFMAG)) &#123;</span><br><span class="line">        LOG_ERR(<span class="string">&quot;\&quot;%s\&quot; has bad ELF magic&quot;</span>, info-&gt;name);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    elf_class = info-&gt;hdr-&gt;e_ident[EI_CLASS];</span><br><span class="line">    <span class="keyword">if</span> (elf_class != ELFCLASS64) &#123;</span><br><span class="line">        <span class="keyword">if</span> (elf_class == ELFCLASS32) &#123;</span><br><span class="line">            LOG_ERR(<span class="string">&quot;\&quot;%s\&quot; is 32-bit instead of 64-bit&quot;</span>, info-&gt;name);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            LOG_ERR(<span class="string">&quot;\&quot;%s\&quot; has unknown ELF class: %d&quot;</span>, info-&gt;name, elf_class);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (info-&gt;hdr-&gt;e_ident[EI_DATA] != ELFDATA2LSB) &#123;</span><br><span class="line">        LOG_ERR(<span class="string">&quot;\&quot;%s\&quot; not little-endian: %d&quot;</span>, info-&gt;name, info-&gt;hdr-&gt;e_ident[EI_DATA]);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (info-&gt;hdr-&gt;e_type != ET_EXEC &amp;&amp; info-&gt;hdr-&gt;e_type != ET_DYN) &#123;</span><br><span class="line">        LOG_ERR(<span class="string">&quot;\&quot;%s\&quot; has unexpected e_type: %d&quot;</span>, info-&gt;name, info-&gt;hdr-&gt;e_type);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (info-&gt;hdr-&gt;e_version != EV_CURRENT) &#123;</span><br><span class="line">        LOG_ERR(<span class="string">&quot;\&quot;%s\&quot; has unexpected e_version: %d&quot;</span>, info-&gt;name, info-&gt;hdr-&gt;e_version);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!elf_check_arch(info-&gt;hdr)) &#123;</span><br><span class="line">        LOG_ERR(<span class="string">&quot;\&quot;%s\&quot; has unexpected e_machine: %d&quot;</span>, info-&gt;name, info-&gt;hdr-&gt;e_machine);</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LOG_DEBUG(<span class="string">&quot;\&quot;%s\&quot; verify elf header done.&quot;</span>, info-&gt;name);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取program_headers</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">read_program_headers</span><span class="params">(<span class="keyword">struct</span> elf_info *info)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (info-&gt;hdr-&gt;e_phoff == <span class="number">0</span>) &#123;</span><br><span class="line">        LOG_ERR(<span class="string">&quot;\&quot;%s\&quot; has no program header table&quot;</span>, info-&gt;name);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (info-&gt;hdr-&gt;e_phnum &lt; <span class="number">1</span> || info-&gt;hdr-&gt;e_phnum &gt; (<span class="number">65536U</span> / <span class="keyword">sizeof</span>(ElfW(Phdr)))) &#123;</span><br><span class="line">        LOG_ERR(<span class="string">&quot;\&quot;%s\&quot; has invalid e_phnum: %d&quot;</span>, info-&gt;name, info-&gt;hdr-&gt;e_phnum);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (info-&gt;hdr-&gt;e_phentsize != <span class="keyword">sizeof</span>(ElfW(Phdr))) &#123;</span><br><span class="line">        LOG_ERR(<span class="string">&quot;\&quot;%s\&quot; has invalid e_phentsize&quot;</span>, info-&gt;name);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (info-&gt;hdr-&gt;e_phoff &gt;= info-&gt;len </span><br><span class="line">            || (info-&gt;hdr-&gt;e_phnum * <span class="keyword">sizeof</span>(ElfW(Phdr)) &gt; info-&gt;len - info-&gt;hdr-&gt;e_phoff)) &#123;</span><br><span class="line">        LOG_ERR(<span class="string">&quot;\&quot;%s\&quot; has invalid offset/size of program header table&quot;</span>, info-&gt;name);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    info-&gt;phdr_table = (ElfW(Phdr) *)((<span class="type">char</span> *)info-&gt;hdr + info-&gt;hdr-&gt;e_phoff);</span><br><span class="line">    LOG_DEBUG(<span class="string">&quot;\&quot;%s\&quot; read program header done.&quot;</span>, info-&gt;name);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="三、elf-module-alloc"><a href="#三、elf-module-alloc" class="headerlink" title="三、elf_module_alloc"></a>三、elf_module_alloc</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模块内存初始化</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> elf_module *<span class="title function_">elf_module_alloc</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">elf_module</span> *<span class="title">m</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(name) &gt;= ELF_MODULE_NAME_LEN) &#123;</span><br><span class="line">        LOG_ERR(<span class="string">&quot;ELF name to long&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*m));</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        LOG_ERR(<span class="string">&quot;\&quot;%s\&quot; elf module memory alloc failed: %s&quot;</span>, name, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(m, <span class="number">0</span>, <span class="keyword">sizeof</span>(*m));</span><br><span class="line">    <span class="built_in">strncpy</span>(m-&gt;name, name, <span class="keyword">sizeof</span>(m-&gt;name) - <span class="number">1</span>);</span><br><span class="line">    INIT_LIST_HEAD(&amp;m-&gt;<span class="built_in">list</span>);</span><br><span class="line">    m-&gt;refcnt = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    LOG_DEBUG(<span class="string">&quot;name %s: allocated struct elf_module @ %p&quot;</span>, name, m);</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放模块</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">elf_module_free</span><span class="params">(<span class="keyword">struct</span> elf_module *m)</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="keyword">if</span> (!m)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    LOG_DEBUG(<span class="string">&quot;name %s: freeing soinfo @ %p&quot;</span>, m-&gt;name, m);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> (m-&gt;base)</span><br><span class="line">        munmap((<span class="type">void</span> *)m-&gt;base, m-&gt;size);</span><br><span class="line">    <span class="built_in">free</span>(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="四、layout-segments"><a href="#四、layout-segments" class="headerlink" title="四、layout_segments"></a>四、layout_segments</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为 ELF 模块的各个段分配虚拟地址空间，并计算加载偏移量</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">layout_segments</span><span class="params">(<span class="keyword">struct</span> elf_module *m, <span class="keyword">struct</span> elf_info *info)</span></span><br><span class="line">&#123;</span><br><span class="line">    ElfW(Addr) min_vaddr;</span><br><span class="line">    <span class="type">void</span> *mm_start;</span><br><span class="line">    <span class="type">size_t</span> i;</span><br><span class="line"></span><br><span class="line">    m-&gt;size = phdr_table_get_load_size(info-&gt;phdr_table, info-&gt;hdr-&gt;e_phnum, &amp;min_vaddr, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (m-&gt;size == <span class="number">0</span>) &#123;</span><br><span class="line">        LOG_ERR(<span class="string">&quot;\&quot;%s\&quot; has no loadable segments&quot;</span>, m-&gt;name);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mm_start = mmap(<span class="literal">NULL</span>,</span><br><span class="line">                    m-&gt;size,</span><br><span class="line">                    PROT_READ | PROT_WRITE | PROT_EXEC, </span><br><span class="line">                    MAP_PRIVATE | MAP_ANONYMOUS,</span><br><span class="line">                    <span class="number">-1</span>,</span><br><span class="line">                    <span class="number">0</span>); <span class="comment">// munmap in elf_module_free()</span></span><br><span class="line">    <span class="keyword">if</span> (mm_start == MAP_FAILED) &#123;</span><br><span class="line">        LOG_ERR(<span class="string">&quot;couldn&#x27;t map \&quot;%s\&quot; address space, %s&quot;</span>, m-&gt;name, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(mm_start, <span class="number">0</span>, m-&gt;size);</span><br><span class="line">    m-&gt;base = (ElfW(Addr))mm_start;</span><br><span class="line">    m-&gt;load_bias = (<span class="type">char</span> *)mm_start - (<span class="type">char</span> *)min_vaddr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; info-&gt;hdr-&gt;e_phnum; ++i) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Phdr)</span> *phdr = &amp;info-&gt;phdr_table[i];</span><br><span class="line">        <span class="keyword">if</span> (phdr-&gt;p_type != PT_LOAD)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (phdr-&gt;p_offset + phdr-&gt;p_filesz &gt; info-&gt;len) &#123;</span><br><span class="line">            LOG_ERR(<span class="string">&quot;\&quot;%s\&quot; has invalid segment[%zu]:&quot;</span></span><br><span class="line">                    <span class="string">&quot;p_offset (%zx) + p_filesz (%zx) past end of %zx)&quot;</span>,</span><br><span class="line">                    m-&gt;name, i, phdr-&gt;p_offset, phdr-&gt;p_filesz, info-&gt;len);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memcpy</span>((<span class="type">char</span> *)m-&gt;load_bias + phdr-&gt;p_vaddr, </span><br><span class="line">               (<span class="type">char</span> *)info-&gt;hdr + phdr-&gt;p_offset, phdr-&gt;p_filesz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="五、find-loaded-phdr"><a href="#五、find-loaded-phdr" class="headerlink" title="五、find_loaded_phdr"></a>五、find_loaded_phdr</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找已经加载的 ELF 模块的程序头表</span></span><br><span class="line"><span class="comment">// 为了拿到so的起始地址和其他的有些信息</span></span><br><span class="line"><span class="type">static</span> <span class="title function_">ElfW</span><span class="params">(Phdr)</span> *<span class="title function_">find_loaded_phdr</span><span class="params">(<span class="keyword">struct</span> elf_module *m, <span class="keyword">struct</span> elf_info *info)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> i;</span><br><span class="line">    ElfW(Addr) loaded_phdr = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Phdr)</span> *pphdr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If there is a PT_PHDR, use it directly.</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, pphdr = info-&gt;phdr_table; i &lt; info-&gt;hdr-&gt;e_phnum; ++i, ++pphdr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pphdr-&gt;p_type == PT_PHDR) &#123;</span><br><span class="line">            loaded_phdr = (ElfW(Addr))(m-&gt;load_bias + pphdr-&gt;p_vaddr);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Otherwise, check the first loadable segment. If its file offset</span></span><br><span class="line">    <span class="comment">// is 0, it starts with the ELF header, and we can trivially find the</span></span><br><span class="line">    <span class="comment">// loaded program header from it.</span></span><br><span class="line">    <span class="keyword">if</span> (loaded_phdr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>, pphdr = info-&gt;phdr_table; i &lt; info-&gt;hdr-&gt;e_phnum; ++i, ++pphdr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pphdr-&gt;p_type == PT_LOAD) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pphdr-&gt;p_offset == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Ehdr)</span> *ehdr = (<span class="type">const</span> ElfW(Ehdr) *)(m-&gt;load_bias + pphdr-&gt;p_vaddr);</span><br><span class="line">                    loaded_phdr = (ElfW(Addr))((<span class="type">char</span> *)ehdr + ehdr-&gt;e_phoff);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (loaded_phdr == <span class="number">0</span>) &#123;</span><br><span class="line">         LOG_ERR(<span class="string">&quot;can&#x27;t find loaded phdr for \&quot;%s\&quot;&quot;</span>, m-&gt;name);</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ensures that our program header is actually within a loadable</span></span><br><span class="line">    <span class="comment">// segment. This should help catch badly-formed ELF files that</span></span><br><span class="line">    <span class="comment">// would cause the linker to crash later when trying to access it.</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, pphdr = info-&gt;phdr_table; i &lt; info-&gt;hdr-&gt;e_phnum; ++i, ++pphdr) &#123;</span><br><span class="line">        ElfW(Addr) seg_start, seg_end;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pphdr-&gt;p_type != PT_LOAD)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        seg_start = m-&gt;load_bias + pphdr-&gt;p_vaddr;</span><br><span class="line">        seg_end = seg_start + pphdr-&gt;p_filesz;</span><br><span class="line">        <span class="keyword">if</span> (seg_start &lt;= loaded_phdr </span><br><span class="line">                &amp;&amp; (loaded_phdr + info-&gt;hdr-&gt;e_phnum * <span class="keyword">sizeof</span>(ElfW(Phdr)) &lt;= seg_end)) &#123;</span><br><span class="line">            LOG_DEBUG(<span class="string">&quot;find loaded phdr for \&quot;%s\&quot; done&quot;</span>, m-&gt;name);</span><br><span class="line">            <span class="keyword">return</span> (ElfW(Phdr) *)loaded_phdr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LOG_ERR(<span class="string">&quot;\&quot;%s\&quot; loaded phdr 0x%zx not in loadable segment&quot;</span>, m-&gt;name, loaded_phdr);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="六、phdr-table-get-dynamic-section"><a href="#六、phdr-table-get-dynamic-section" class="headerlink" title="六、phdr_table_get_dynamic_section"></a>六、phdr_table_get_dynamic_section</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从程序头表中提取动态段（.dynamic 段）</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">phdr_table_get_dynamic_section</span><span class="params">(<span class="type">const</span> ElfW(Phdr) *phdr_table, <span class="type">size_t</span> phdr_count,</span></span><br><span class="line"><span class="params">                                           ElfW(Addr) load_bias, ElfW(Dyn) **dynamic,</span></span><br><span class="line"><span class="params">                                           ElfW(Word) *dynamic_flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> i;</span><br><span class="line"></span><br><span class="line">    *dynamic = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; phdr_count; ++i) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Phdr)</span> *phdr = &amp;phdr_table[i];</span><br><span class="line">        <span class="keyword">if</span> (phdr-&gt;p_type == PT_DYNAMIC) &#123;</span><br><span class="line">            *dynamic = (ElfW(Dyn) *)(load_bias + phdr-&gt;p_vaddr);</span><br><span class="line">            <span class="keyword">if</span> (dynamic_flags)</span><br><span class="line">                *dynamic_flags = phdr-&gt;p_flags;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="七、load-dynamic"><a href="#七、load-dynamic" class="headerlink" title="七、load_dynamic"></a>七、load_dynamic</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载动态段中的信息（如符号表、字符串表、重定位表等</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">load_dynamic</span><span class="params">(<span class="keyword">struct</span> elf_module *m)</span></span><br><span class="line">&#123;</span><br><span class="line">    ElfW(Dyn) *d;</span><br><span class="line"></span><br><span class="line">    m-&gt;needed_count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (d = m-&gt;dynamic; d-&gt;d_tag != DT_NULL; ++d) &#123;</span><br><span class="line">        LOG_DEBUG(<span class="string">&quot;d = %p, d[0](tag) = 0x%p d[1](val) = 0x%p&quot;</span>, </span><br><span class="line">                  d, (<span class="type">void</span> *)d-&gt;d_tag, (<span class="type">void</span> *)d-&gt;d_un.d_val);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">switch</span> (d-&gt;d_tag) &#123;</span><br><span class="line">        <span class="keyword">case</span> DT_HASH:</span><br><span class="line">            m-&gt;nbucket = ((<span class="type">uint32_t</span> *)(m-&gt;load_bias + d-&gt;d_un.d_ptr))[<span class="number">0</span>];</span><br><span class="line">            m-&gt;nchain = ((<span class="type">uint32_t</span> *)(m-&gt;load_bias + d-&gt;d_un.d_ptr))[<span class="number">1</span>];</span><br><span class="line">            m-&gt;bucket = (<span class="type">uint32_t</span> *)(m-&gt;load_bias + d-&gt;d_un.d_ptr + <span class="number">8</span>);</span><br><span class="line">            m-&gt;chain = (<span class="type">uint32_t</span> *)(m-&gt;load_bias + d-&gt;d_un.d_ptr + <span class="number">8</span> + m-&gt;nbucket *<span class="number">4</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DT_GNU_HASH:</span><br><span class="line">            m-&gt;gnu_nbucket = ((<span class="type">uint32_t</span> *)(m-&gt;load_bias + d-&gt;d_un.d_ptr))[<span class="number">0</span>];</span><br><span class="line">            <span class="comment">// skip symndx</span></span><br><span class="line">            m-&gt;gnu_maskwords = ((<span class="type">uint32_t</span> *)(m-&gt;load_bias + d-&gt;d_un.d_ptr))[<span class="number">2</span>];</span><br><span class="line">            m-&gt;gnu_shift2 = ((<span class="type">uint32_t</span> *)(m-&gt;load_bias + d-&gt;d_un.d_ptr))[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">            m-&gt;gnu_bloom_filter = (ElfW(Addr) *)(m-&gt;load_bias + d-&gt;d_un.d_ptr + <span class="number">16</span>);</span><br><span class="line">            m-&gt;gnu_bucket = (<span class="type">uint32_t</span> *)(m-&gt;gnu_bloom_filter + m-&gt;gnu_maskwords);</span><br><span class="line">            <span class="comment">// amend chain for symndx = header[1]</span></span><br><span class="line">            m-&gt;gnu_chain = m-&gt;gnu_bucket + m-&gt;gnu_nbucket -</span><br><span class="line">                ((<span class="type">uint32_t</span> *)(m-&gt;load_bias + d-&gt;d_un.d_ptr))[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!powerof2(m-&gt;gnu_maskwords)) &#123;</span><br><span class="line">                LOG_ERR(<span class="string">&quot;invalid maskwords for gnu_hash = 0x%x, in \&quot;%s\&quot; expecting power to two&quot;</span>,</span><br><span class="line">                        m-&gt;gnu_maskwords, m-&gt;name);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            m-&gt;gnu_maskwords--;</span><br><span class="line">            m-&gt;flags |= FLAG_GNU_HASH;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DT_STRTAB:</span><br><span class="line">            m-&gt;strtab = (<span class="type">char</span> *)(m-&gt;load_bias + d-&gt;d_un.d_ptr);</span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        <span class="keyword">case</span> DT_STRSZ:</span><br><span class="line">            m-&gt;strtab_size = d-&gt;d_un.d_val;</span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        <span class="keyword">case</span> DT_SYMTAB:</span><br><span class="line">            m-&gt;symtab = (ElfW(Sym) *)(m-&gt;load_bias + d-&gt;d_un.d_ptr);</span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        <span class="keyword">case</span> DT_SYMENT:</span><br><span class="line">            <span class="keyword">if</span> (d-&gt;d_un.d_val != <span class="keyword">sizeof</span>(ElfW(Sym))) &#123;</span><br><span class="line">                LOG_ERR(<span class="string">&quot;invalid DT_SYMENT: %zu in \&quot;%s\&quot;&quot;</span>, (<span class="type">size_t</span>)d-&gt;d_un.d_val, m-&gt;name);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DT_PLTREL:</span><br><span class="line">            <span class="keyword">if</span> (d-&gt;d_un.d_val != DT_RELA) &#123;</span><br><span class="line">                LOG_ERR(<span class="string">&quot;unsupported DT_PLTREL in \&quot;%s\&quot;; expected DT_RELA&quot;</span>, m-&gt;name);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DT_JMPREL:</span><br><span class="line">            m-&gt;plt_rela = (ElfW(Rela) *)(m-&gt;load_bias + d-&gt;d_un.d_ptr);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DT_PLTRELSZ:</span><br><span class="line">            m-&gt;plt_rela_count = d-&gt;d_un.d_val / <span class="keyword">sizeof</span>(ElfW(Rela));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DT_RELA:</span><br><span class="line">            m-&gt;rela = (ElfW(Rela) *)(m-&gt;load_bias + d-&gt;d_un.d_ptr);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DT_RELASZ:</span><br><span class="line">            m-&gt;rela_count = d-&gt;d_un.d_val /<span class="keyword">sizeof</span>(ElfW(Rela));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DT_RELAENT:</span><br><span class="line">            <span class="keyword">if</span> (d-&gt;d_un.d_val != <span class="keyword">sizeof</span>(ElfW(Rela))) &#123;</span><br><span class="line">                LOG_ERR(<span class="string">&quot;invalid DT_RELAENT: %zu&quot;</span>, (<span class="type">size_t</span>)d-&gt;d_un.d_val);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DT_REL:</span><br><span class="line">            LOG_ERR(<span class="string">&quot;unsupported DT_REL in \&quot;%s\&quot;&quot;</span>, m-&gt;name);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">case</span> DT_RELSZ:</span><br><span class="line">            LOG_ERR(<span class="string">&quot;unsupported DT_RELSZ in \&quot;%s\&quot;&quot;</span>, m-&gt;name);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">case</span> DT_NEEDED:</span><br><span class="line">            m-&gt;needed_count++;</span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            LOG_DEBUG(<span class="string">&quot;\&quot;%s\&quot; unused DT entry: type %p arg %p&quot;</span>,</span><br><span class="line">                      m-&gt;name, (<span class="type">void</span> *)d-&gt;d_tag, (<span class="type">void</span> *)d-&gt;d_un.d_val);</span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LOG_DEBUG(<span class="string">&quot;mod-&gt;base = %zx, mod-&gt;strtab = %p, mod-&gt;symtab = %p&quot;</span>,</span><br><span class="line">              m-&gt;base, m-&gt;strtab, m-&gt;symtab);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sanity checks.</span></span><br><span class="line">    <span class="keyword">if</span> (m-&gt;nbucket == <span class="number">0</span> &amp;&amp; m-&gt;gnu_nbucket == <span class="number">0</span>) &#123;</span><br><span class="line">        LOG_ERR(<span class="string">&quot;empty/missing DT_HASH/DT_GNU_HASH in \&quot;%s\&quot; &quot;</span></span><br><span class="line">                <span class="string">&quot;(new hash type from the future?)&quot;</span>, m-&gt;name);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (m-&gt;strtab == <span class="number">0</span>) &#123;</span><br><span class="line">        LOG_ERR(<span class="string">&quot;empty/missing DT_STRTAB in \&quot;%s\&quot;&quot;</span>, m-&gt;name);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (m-&gt;symtab == <span class="number">0</span>) &#123;</span><br><span class="line">        LOG_ERR(<span class="string">&quot;empty/missing DT_SYMTAB in \&quot;%s\&quot;&quot;</span>, m-&gt;name);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="八、elf-link"><a href="#八、elf-link" class="headerlink" title="八、elf_link"></a>八、elf_link</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行动态链接，解析符号并应用重定位</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">elf_link</span><span class="params">(<span class="keyword">struct</span> elf_module *m)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bool</span> ret = <span class="literal">false</span>;</span><br><span class="line">    ElfW(Dyn) *d;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">elf_module</span> **<span class="title">needed</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">elf_module</span> **<span class="title">pneeded</span>;</span></span><br><span class="line"></span><br><span class="line">    LOG_DEBUG(<span class="string">&quot;[ linking %s ]&quot;</span>, m-&gt;name);</span><br><span class="line">    LOG_DEBUG(<span class="string">&quot;mod-&gt;base = %zx mod-&gt;flags = 0x%08x&quot;</span>, m-&gt;base, m-&gt;flags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* load needed module */</span></span><br><span class="line">    pneeded = needed = (<span class="keyword">struct</span> elf_module **)<span class="built_in">malloc</span>((<span class="number">1</span> + m-&gt;needed_count) * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> elf_module *));</span><br><span class="line">    <span class="keyword">if</span> (needed == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        LOG_ERR(<span class="string">&quot;\&quot;%s\&quot;malloc for needed array failed&quot;</span>, m-&gt;name);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (d = m-&gt;dynamic; d-&gt;d_tag != DT_NULL; ++d) &#123;</span><br><span class="line">        <span class="keyword">if</span> (d-&gt;d_tag == DT_NEEDED) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">elf_module</span> *<span class="title">need_mod</span>;</span></span><br><span class="line">            <span class="type">const</span> <span class="type">char</span> *need_name = m-&gt;strtab + d-&gt;d_un.d_val;</span><br><span class="line">            LOG_DEBUG(<span class="string">&quot;%s needs %s&quot;</span>, m-&gt;name, need_name);</span><br><span class="line">            need_mod = find_module(need_name);</span><br><span class="line">            <span class="keyword">if</span> (need_mod != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                need_mod-&gt;refcnt++;</span><br><span class="line">                *pneeded++ = need_mod;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            LOG_DEBUG(<span class="string">&quot;load module %s use dlopen()&quot;</span>, m-&gt;name);</span><br><span class="line">            <span class="keyword">if</span> (dlopen(need_name, RTLD_NOW | RTLD_GLOBAL) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                LOG_ERR(<span class="string">&quot;could not load module \&quot;%s\&quot; needed by \&quot;%s\&quot;&quot;</span>, need_name, m-&gt;name);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *pneeded = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m-&gt;rela != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        LOG_DEBUG(<span class="string">&quot;[ relocating %s ]&quot;</span>, m-&gt;name);</span><br><span class="line">        <span class="keyword">if</span> (!apply_relocate_add(m, m-&gt;rela, m-&gt;rela_count, needed))</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m-&gt;plt_rela != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        LOG_DEBUG(<span class="string">&quot;[ relocating %s plt ]&quot;</span>, m-&gt;name);</span><br><span class="line">        <span class="keyword">if</span> (!apply_relocate_add(m, m-&gt;plt_rela, m-&gt;plt_rela_count, needed))</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    m-&gt;flags |= FLAG_LINKED;</span><br><span class="line">    ret = <span class="literal">true</span>;</span><br><span class="line">out:</span><br><span class="line">    <span class="built_in">free</span>(needed);</span><br><span class="line">    LOG_DEBUG(<span class="string">&quot;[ finished linking %s, ret=%d ]&quot;</span>, m-&gt;name, ret);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="九、list-add-tail"><a href="#九、list-add-tail" class="headerlink" title="九、list_add_tail"></a>九、list_add_tail</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将新模块添加到模块列表的尾部 类比soinfo_list</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">list_add_tail</span><span class="params">(<span class="keyword">struct</span> list_head *new, <span class="keyword">struct</span> list_head *head)</span></span><br><span class="line">&#123;</span><br><span class="line">	__list_add(new, head-&gt;prev, head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，上述九个模块的已经实现了。</p>
<p>谈谈我对elf_loador的理解吧：我认为，loador的过程实际上就是先分配虚拟内存，把elf文件映射到内存中，由于里面的函数可能会引用外部函数，所以又有了链接过程，最后为了方便管理，又维护了个so_list的链表，仅此。</p>
<h3 id="0x03-如何加载elf里的函数"><a href="#0x03-如何加载elf里的函数" class="headerlink" title="0x03 如何加载elf里的函数"></a>0x03 如何加载elf里的函数</h3><p>这个其实看了上面的加载流程就知道了</p>
<p>加载elf实际上是把目标elf文件映射到自己进程的内存空间，这有点像so的注入，实际也恰恰如此，下一篇我会详细写so注入。此时elf已经被映射到自己的内存中了，那我调用elf里的函数只需拿到目标函数的起始地址即可。所以可以通过在elf中查找symbol从而获取函数相对于so的偏移，再加上so在内存中的起始地址就是我们的函数在内存中的地址了。接下来就可以舒服的玩耍了。</p>
<h4 id="贴一下代码吧"><a href="#贴一下代码吧" class="headerlink" title="贴一下代码吧"></a>贴一下代码吧</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">is_symbol_global_and_defined</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> elf_module *m, <span class="type">const</span> ElfW(Sym) *s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (ELFW(ST_BIND)(s-&gt;st_info) == STB_GLOBAL || ELFW(ST_BIND)(s-&gt;st_info) == STB_WEAK)</span><br><span class="line">        <span class="keyword">return</span> s-&gt;st_shndx != SHN_UNDEF;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算hsah</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> <span class="title function_">elfhash</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint8_t</span> *name_bytes = (<span class="type">const</span> <span class="type">uint8_t</span> *)name;</span><br><span class="line">    <span class="type">uint32_t</span> h = <span class="number">0</span>, g;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span> (*name_bytes) &#123;</span><br><span class="line">        h = (h &lt;&lt; <span class="number">4</span>) + *name_bytes++;</span><br><span class="line">        g = h &amp; <span class="number">0xf0000000</span>;</span><br><span class="line">        h ^= g;</span><br><span class="line">        h ^= g &gt;&gt; <span class="number">24</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找hash对应的符号</span></span><br><span class="line"><span class="comment">//在 ELF（Executable and Linkable Format）文件中，符号（Symbol）不仅仅指函数，还可以指变量、常量、数据结构等。符号表（Symbol Table）是 ELF 文件中的一个重要部分，它记录了程序中所有符号的信息。</span></span><br><span class="line"><span class="type">static</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span> *<span class="title function_">elfhash_lookup</span><span class="params">(<span class="keyword">struct</span> elf_module *m, <span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> n;</span><br><span class="line">    <span class="type">uint32_t</span> hash = elfhash(name);</span><br><span class="line">    ElfW(Sym) *symtab = m-&gt;symtab;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *strtab = m-&gt;strtab;</span><br><span class="line"></span><br><span class="line">    LOG_DEBUG(<span class="string">&quot;SEARCH %s in %s@0x%zx %08x %zu&quot;</span>, name, m-&gt;name, m-&gt;base, hash, hash % m-&gt;nbucket);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历hashmap</span></span><br><span class="line">    <span class="keyword">for</span> (n = m-&gt;bucket[hash % m-&gt;nbucket]; n != <span class="number">0</span>; n = m-&gt;chain[n]) &#123;</span><br><span class="line">        ElfW(Sym) *s = symtab + n;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(strtab + s-&gt;st_name, name))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (is_symbol_global_and_defined(m, s)) &#123;</span><br><span class="line">            LOG_DEBUG(<span class="string">&quot;FOUND %s in %s (%zx) %zu&quot;</span>, name, m-&gt;name, s-&gt;st_value, s-&gt;st_size);</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算字符串的哈希值</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> <span class="title function_">gnuhash</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint8_t</span> *name_bytes = (<span class="type">const</span> <span class="type">uint8_t</span> *)name;</span><br><span class="line">    <span class="type">uint32_t</span> h = <span class="number">5381</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (*name_bytes != <span class="number">0</span>)</span><br><span class="line">        h += (h &lt;&lt; <span class="number">5</span>) + *name_bytes++; <span class="comment">// h*33 + c = h + h * 32 + c = h + h &lt;&lt; 5 + c</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基于 GNU 哈希表的符号查找函数基于 GNU 哈希表的符号查找函数</span></span><br><span class="line"><span class="type">static</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span> *<span class="title function_">gnuhash_lookup</span><span class="params">(<span class="keyword">struct</span> elf_module *m, <span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> n;</span><br><span class="line">    <span class="type">uint32_t</span> hash = gnuhash(name);</span><br><span class="line">    <span class="type">uint32_t</span> h2 = hash &gt;&gt; m-&gt;gnu_shift2;</span><br><span class="line">    <span class="type">uint32_t</span> bloom_mask_bits = <span class="keyword">sizeof</span>(ElfW(Addr)) * <span class="number">8</span>;</span><br><span class="line">    <span class="type">uint32_t</span> word_num = (hash / bloom_mask_bits) &amp; m-&gt;gnu_maskwords;</span><br><span class="line">    ElfW(Addr) bloom_word = m-&gt;gnu_bloom_filter[word_num];</span><br><span class="line">    ElfW(Sym) *symtab = m-&gt;symtab;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *strtab = m-&gt;strtab;</span><br><span class="line"></span><br><span class="line">    LOG_DEBUG(<span class="string">&quot;SEARCH %s in %s@%p (gnu)&quot;</span>, name, m-&gt;name, (<span class="type">void</span> *)m-&gt;base);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// test against bloom filter</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="number">1</span> &amp; (bloom_word &gt;&gt; (hash % bloom_mask_bits)) &amp; (bloom_word &gt;&gt; (h2 % bloom_mask_bits))) == <span class="number">0</span>) &#123;</span><br><span class="line">        LOG_DEBUG(<span class="string">&quot;NOT FOUND %s in %s@%p (gnu)&quot;</span>, name, m-&gt;name, (<span class="type">void</span> *)m-&gt;base);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bloom test says &quot;probably yes&quot;...</span></span><br><span class="line">    n = m-&gt;gnu_bucket[hash % m-&gt;gnu_nbucket];</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        LOG_DEBUG(<span class="string">&quot;NOT FOUND %s in %s@%p (gun)&quot;</span>, name, m-&gt;name, (<span class="type">void</span> *)m-&gt;base);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        ElfW(Sym) *s = symtab + n;</span><br><span class="line">        <span class="keyword">if</span> (((m-&gt;gnu_chain[n] ^ hash) &gt;&gt; <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(strtab + s-&gt;st_name, name))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (is_symbol_global_and_defined(m, s)) &#123;</span><br><span class="line">            LOG_DEBUG(<span class="string">&quot;FOUND %s in %s (%p) %zd&quot;</span>, name, m-&gt;name, (<span class="type">void</span> *)s-&gt;st_value, (<span class="type">size_t</span>)s-&gt;st_size);</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((m-&gt;gnu_chain[n++] &amp; <span class="number">1</span>) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在so中查找符号</span></span><br><span class="line">ElfW(Sym) *lookup_symbol_in_module(<span class="keyword">struct</span> elf_module *m, <span class="type">const</span> <span class="type">char</span> *name)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (m-&gt;flags &amp; FLAG_GNU_HASH) ? gnuhash_lookup(m, name) : elfhash_lookup(m, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="0x04-小结"><a href="#0x04-小结" class="headerlink" title="0x04 小结"></a>0x04 小结</h3><p>以上几乎就是全部流程的代码了，再贴一下调用代码吧。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> elf_module *<span class="title function_">load_elf_module</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">const</span> <span class="type">void</span> *elf_data, <span class="type">size_t</span> elf_len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">elf_info</span> <span class="title">info</span> =</span> &#123; .name = name, .hdr = elf_data, .len = elf_len &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">elf_module</span> *<span class="title">m</span>;</span></span><br><span class="line"></span><br><span class="line">    LOG_DEBUG(<span class="string">&quot;load_elf_module: name=%s, bin=%p, len=%zu&quot;</span>, name, elf_data, elf_len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (find_module(name)) &#123;</span><br><span class="line">        LOG_ERR(<span class="string">&quot;\&quot;%s\&quot; already exist&quot;</span>, name);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!verify_elf_header(&amp;info) || !read_program_headers(&amp;info))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    m = elf_module_alloc(name);</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!layout_segments(m, &amp;info)) <span class="comment">// 此时 ELF 文件的程序头表（info.hdr-&gt;e_phoff）已经可以映射到内存中的正确位置</span></span><br><span class="line">        <span class="keyword">goto</span> out_free;</span><br><span class="line"></span><br><span class="line">    m-&gt;phdr = find_loaded_phdr(m, &amp;info); <span class="comment">// 查找 ELF 模块的程序头表</span></span><br><span class="line">    <span class="keyword">if</span> (m-&gt;phdr == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> out_free;</span><br><span class="line">    m-&gt;phnum = info.hdr-&gt;e_phnum;</span><br><span class="line">    m-&gt;entry = m-&gt;load_bias + info.hdr-&gt;e_entry;</span><br><span class="line"></span><br><span class="line">    phdr_table_get_dynamic_section(m-&gt;phdr, m-&gt;phnum, m-&gt;load_bias, &amp;m-&gt;dynamic, <span class="literal">NULL</span>); <span class="comment">// 从程序头表中提取动态段（.dynamic 段）</span></span><br><span class="line">    <span class="keyword">if</span> (m-&gt;dynamic) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!load_dynamic(m)) <span class="comment">// 加载动态段中的信息（如符号表、字符串表、重定位表等</span></span><br><span class="line">            <span class="keyword">goto</span> out_free;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!elf_link(m)) <span class="comment">// 执行动态链接，解析符号并应用重定位</span></span><br><span class="line">            <span class="keyword">goto</span> out_free;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    list_add_tail(&amp;m-&gt;<span class="built_in">list</span>, &amp;mod_list); <span class="comment">// 将新模块添加到模块列表的尾部 类比soinfo_list</span></span><br><span class="line">    </span><br><span class="line">    LOG_DEBUG(<span class="string">&quot;[ \&quot;%s\&quot; load done, base=0x%zx sz=0x%zx entry=0x%zx ]&quot;</span>, </span><br><span class="line">              m-&gt;name, m-&gt;base, m-&gt;size, m-&gt;entry);</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line"></span><br><span class="line">out_free:</span><br><span class="line">    elf_module_free(m);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">unload_elf_module</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">elf_module</span> *<span class="title">m</span>;</span></span><br><span class="line">    ElfW(Dyn) *d;</span><br><span class="line">    </span><br><span class="line">    m = find_module(name);</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (m-&gt;refcnt == <span class="number">1</span>) &#123;</span><br><span class="line">        LOG_DEBUG(<span class="string">&quot;unloading \&quot;%s\&quot;&quot;</span>, m-&gt;name);</span><br><span class="line"></span><br><span class="line">        list_del(&amp;m-&gt;<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (d = m-&gt;dynamic; d-&gt;d_tag != DT_NULL; ++d) &#123;</span><br><span class="line">            <span class="keyword">if</span> (d-&gt;d_tag == DT_NEEDED) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="type">char</span> *need_name = m-&gt;strtab + d-&gt;d_un.d_val;</span><br><span class="line">                LOG_DEBUG(<span class="string">&quot;%s needs to unload %s&quot;</span>, m-&gt;name, need_name);</span><br><span class="line">                unload_elf_module(need_name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        elf_module_free(m);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        m-&gt;refcnt--;</span><br><span class="line">        LOG_DEBUG(<span class="string">&quot;not unloading \&quot;%s\&quot;, decrementing refcnt to %zu&quot;</span>, m-&gt;name, m-&gt;refcnt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*<span class="type">main_func_t</span>)</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">run_elf_module</span><span class="params">(<span class="keyword">struct</span> elf_module *m, <span class="type">const</span> <span class="type">char</span> *func)</span></span><br><span class="line">&#123;</span><br><span class="line">    ElfW(Sym *) s = lookup_symbol_in_module(m, func);</span><br><span class="line">    <span class="type">main_func_t</span> fn;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!s) &#123;</span><br><span class="line">        LOG_ERR(<span class="string">&quot;not found function %s&quot;</span>, func);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn = (<span class="type">void</span> *)(m-&gt;load_bias + s-&gt;st_value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fn();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结下来，elf_loador就做了上面那几件事，实际上就是自己实现了部分<strong>mmap</strong>和部分<strong>dlsym</strong>的功能，代码还是很清晰的。</p>
<p>代码摘自: <a target="_blank" rel="noopener" href="https://github.com/SoyBeanMilkx/elfloader/blob/master/elf_loader.c">elfloader/elf_loader.c at master · SoyBeanMilkx/elfloader · GitHub</a></p>

        
      </div>

         
    </div>
    
     
  </div>
  
    
<nav id="article-nav">
  <a class="article-nav-btn left  disabled "
     >
    <i class="fa-solid fa-angle-left"></i>
    <p class="title-text">
        
    </p>
  </a>
  <a class="article-nav-btn right "
    
      href="/2024/12/25/HelloBlog/"
      title="NEW BLOG!!"
     >

    <p class="title-text">
      
        NEW BLOG!!
        
    </p>
    <i class="fa-solid fa-angle-right"></i>
  </a>
</nav>


  
</article>





    </div>
    <div id="footer-wrapper">
      <footer id="footer" style="text-align: center;">
  <div id="footer-info" class="inner">
    <p>到底了</p>
    <p>
      &copy; 2024 Yuuki
    </p>
  </div>
</footer>
    </div>
    <div class="back-to-top-wrapper">
    <button id="back-to-top-btn" class="back-to-top-btn hide" onclick="topFunction()">
        <i class="fa-solid fa-angle-up"></i>
    </button>
</div>

<script>
    function topFunction() {
        window.scroll({ top: 0, behavior: 'smooth' });
    }
    let btn = document.getElementById('back-to-top-btn');
    function scrollFunction() {
        if (document.body.scrollTop > 600 || document.documentElement.scrollTop > 600) {
            btn.classList.remove('hide')
        } else {
            btn.classList.add('hide')
        }
    }
    window.onscroll = function() {
        scrollFunction();
    }
</script>

  </div>
  <script src="/js/light-dark-switch.js"></script>
</body>
</html>
